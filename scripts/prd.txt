# Complete Implementation Plan: Centralized SSH Key Management with Command Auditing

## Part 1: GitHub Key Repository Setup

1. Create a GitHub repository (private) to store SSH keys:
   ```bash
   # Create locally and push to GitHub
   mkdir ssh-keys-repo
   cd ssh-keys-repo
   touch authorized_keys
   git init
   git add authorized_keys
   git commit -m "Initial commit with empty authorized_keys file"
   ```

2. Add your initial admin SSH public key to the authorized_keys file:
   ```bash
   # Add your key
   echo "ssh-rsa AAAA..." >> authorized_keys
   git commit -m "Add admin SSH key"
   ```

3. Create and push to GitHub:
   ```bash
   # Create a new private repository on GitHub first, then:
   git remote add origin git@github.com:your-org/ssh-keys.git
   git push -u origin main
   ```

4. Set up branch protection on GitHub:
   - Go to repository Settings > Branches
   - Add rule for the main branch
   - Enable "Require pull request reviews before merging"
   - Enable "Require approvals" (set to at least 1)
   - Save changes

5. Create a PR template for key additions:
   - Create file `.github/pull_request_template.md` in your repository:
   ```md
   ## SSH Key Addition
   
   - [ ] This key follows the proper SSH public key format
   - [ ] I've confirmed this key belongs to an authorized user
   - [ ] The key has an appropriate comment identifying the user
   
   User Name: 
   Purpose:
   Expiration (if any):
   ```

## Part 2: Bastion Server SSH Key Management

1. Install required packages:
   ```bash
   sudo apt-get update
   sudo apt-get install -y curl git jq
   ```

2. Create the key update script at `/usr/local/bin/update_ssh_keys.sh`:
   ```bash
   sudo nano /usr/local/bin/update_ssh_keys.sh
   ```
   
   Add this content:
   ```bash
   #!/bin/bash
   set -e
   
   # Configuration
   GITHUB_REPO="https://raw.githubusercontent.com/your-org/ssh-keys/main"
   KEYS_FILE="authorized_keys"
   LOCAL_FILE="/etc/ssh/authorized_keys"
   LOG_FILE="/var/log/ssh_key_updates.log"
   
   # Log function
   log() {
     echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $LOG_FILE
   }
   
   log "Starting SSH key update"
   
   # Fetch the authorized_keys file from GitHub
   if ! curl -s -f -o /tmp/$KEYS_FILE $GITHUB_REPO/$KEYS_FILE; then
     log "ERROR: Failed to download authorized_keys from GitHub"
     exit 1
   fi
   
   # Verify it's not empty and has SSH key format
   if [ ! -s "/tmp/$KEYS_FILE" ] || ! grep -q "ssh-" "/tmp/$KEYS_FILE"; then
     log "ERROR: Downloaded file is empty or invalid"
     exit 1
   fi
   
   # Compare with current file to see if update is needed
   if [ -f "$LOCAL_FILE" ] && cmp -s "/tmp/$KEYS_FILE" "$LOCAL_FILE"; then
     log "No changes detected in authorized_keys"
     exit 0
   fi
   
   # Back up current file if it exists
   if [ -f "$LOCAL_FILE" ]; then
     cp "$LOCAL_FILE" "${LOCAL_FILE}.bak"
   fi
   
   # Update the authorized_keys file
   # Make immutable flag removable if set
   if command -v chattr &>/dev/null && [ -f "$LOCAL_FILE" ]; then
     lsattr -l "$LOCAL_FILE" | grep -q "Immutable" && chattr -i "$LOCAL_FILE"
   fi
   cp "/tmp/$KEYS_FILE" "$LOCAL_FILE"
   chown root:root "$LOCAL_FILE"
   chmod 644 "$LOCAL_FILE"
   
   # Make immutable to prevent local changes
   if command -v chattr &>/dev/null; then
     chattr +i "$LOCAL_FILE" 2>/dev/null || true
   fi
   
   log "SSH keys updated successfully"
   
   # Restart SSH service if keys changed
   systemctl restart sshd
   log "SSH service restarted"
   
   # Clean up
   rm /tmp/$KEYS_FILE
   ```

3. Make script executable:
   ```bash
   sudo chmod +x /usr/local/bin/update_ssh_keys.sh
   ```

4. Create cron job to run every 5 minutes:
   ```bash
   echo "*/5 * * * * root /usr/local/bin/update_ssh_keys.sh" | sudo tee /etc/cron.d/update_ssh_keys
   ```

5. Create log file:
   ```bash
   sudo touch /var/log/ssh_key_updates.log
   sudo chmod 644 /var/log/ssh_key_updates.log
   ```

6. Configure SSH to use central keys file:
   ```bash
   sudo nano /etc/ssh/sshd_config
   ```
   
   Add or modify these lines:
   ```
   # Use centralized authorized_keys file
   AuthorizedKeysFile /etc/ssh/authorized_keys
   
   # Disable other authentication methods
   PasswordAuthentication no
   ChallengeResponseAuthentication no
   
   # Enable TCP forwarding for tunneling if needed
   AllowTcpForwarding yes
   ```

7. Run initial key update:
   ```bash
   sudo /usr/local/bin/update_ssh_keys.sh
   ```

## Part 3: Command Auditing Setup

1. Create directory for session logs:
   ```bash
   sudo mkdir -p /var/log/user-sessions
   sudo chmod 1733 /var/log/user-sessions
   ```

2. Set up command logging for all users:
   ```bash
   sudo nano /etc/profile.d/command-audit.sh
   ```
   
   Add the following:
   ```bash
   #!/bin/bash
   
   # Start session logging
   if [ -z "$SCRIPT_STARTED" ] && [ "$USER" != "root" ]; then
     export SCRIPT_STARTED=true
     SESSION_LOG="/var/log/user-sessions/$USER-$(date +%Y%m%d-%H%M%S).log"
     script -q -f -t 2> >(logger -t "USER:$USER") "$SESSION_LOG"
     exit
   fi
   
   # Set command history with timestamps
   export HISTTIMEFORMAT="%F %T "
   export HISTSIZE=10000
   export HISTFILESIZE=10000
   export PROMPT_COMMAND='history -a;logger -t "USER:$USER:$PWD" "$(history 1 | cut -c 8-)"'
   ```

3. Make the script executable:
   ```bash
   sudo chmod +x /etc/profile.d/command-audit.sh
   ```

4. Configure SSH to log all connections:
   ```bash
   sudo nano /etc/ssh/sshd_config
   ```
   
   Add or modify:
   ```
   # Enable logging
   SyslogFacility AUTH
   LogLevel VERBOSE
   ```

5. Setup log rotation:
   ```bash
   sudo nano /etc/logrotate.d/user-sessions
   ```
   
   Add:
   ```
   /var/log/user-sessions/*.log {
     rotate 30
     daily
     compress
     missingok
     notifempty
   }
   ```

6. Configure system to record session start/end times:
   ```bash
   sudo nano /etc/pam.d/sshd
   ```
   
   Add at the end:
   ```
   # Log all SSH sessions
   session required pam_unix.so
   session required pam_lastlog.so showfailed
   ```

## Part 4: Network Access Control

1. Install iptables persistent:
   ```bash
   sudo apt install iptables-persistent
   ```

2. Configure iptables to restrict outbound connections:
   ```bash
   # Create a new script to manage firewall rules
   sudo nano /usr/local/bin/configure-firewall.sh
   ```
   
   Add the following content (modify IPs/ports as needed):
   ```bash
   #!/bin/bash
   
   # Flush existing rules
   iptables -F
   iptables -X
   
   # Default policies
   iptables -P INPUT DROP
   iptables -P FORWARD DROP
   iptables -P OUTPUT DROP
   
   # Allow loopback
   iptables -A INPUT -i lo -j ACCEPT
   iptables -A OUTPUT -o lo -j ACCEPT
   
   # Allow established connections
   iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
   iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
   
   # Allow SSH inbound
   iptables -A INPUT -p tcp --dport 22 -j ACCEPT
   
   # Allow specific outbound connections
   # Kubernetes API server
   iptables -A OUTPUT -p tcp -d your-eks-api-server --dport 443 -j ACCEPT
   
   # MySQL database
   iptables -A OUTPUT -p tcp -d your-mysql-server --dport 3306 -j ACCEPT
   
   # PostgreSQL database
   iptables -A OUTPUT -p tcp -d your-postgres-server --dport 5432 -j ACCEPT
   
   # DNS
   iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
   iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
   
   # Allow SSH outbound for tunneling
   iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
   
   # GitHub access for SSH key updates
   iptables -A OUTPUT -p tcp -d github.com --dport 443 -j ACCEPT
   iptables -A OUTPUT -p tcp -d raw.githubusercontent.com --dport 443 -j ACCEPT
   
   # Save rules
   iptables-save > /etc/iptables/rules.v4
   ```

3. Make the script executable and run it:
   ```bash
   sudo chmod +x /usr/local/bin/configure-firewall.sh
   sudo /usr/local/bin/configure-firewall.sh
   ```

## Part 5: System Monitoring and Alerts

1. Install monitoring tools:
   ```bash
   sudo apt install auditd
   ```

2. Configure file integrity monitoring:
   ```bash
   sudo nano /etc/audit/rules.d/audit.rules
   ```
   
   Add:
   ```
   # Monitor SSH configuration
   -w /etc/ssh/sshd_config -p wa -k sshd_config
   -w /etc/ssh/authorized_keys -p wa -k ssh_keys
   
   # Monitor sudoers
   -w /etc/sudoers -p wa -k sudoers
   -w /etc/sudoers.d/ -p wa -k sudoers
   
   # Monitor user modifications
   -w /etc/passwd -p wa -k user_modification
   -w /etc/shadow -p wa -k user_modification
   -w /etc/group -p wa -k user_modification
   
   # Monitor login/logout events
   -w /var/log/wtmp -p wa -k session
   -w /var/log/btmp -p wa -k session
   -w /var/run/utmp -p wa -k session
   ```

3. Restart audit daemon:
   ```bash
   sudo systemctl restart auditd
   ```

4. Configure syslog to alert on specific events:
   ```bash
   sudo nano /etc/rsyslog.d/90-security-alerts.conf
   ```
   
   Add:
   ```
   # Send security alerts to a specific file
   if $programname == 'sudo' or $programname == 'sshd' or $programname == 'auditd' then /var/log/security-alerts.log
   & stop
   ```

5. Create the alerts log and restart rsyslog:
   ```bash
   sudo touch /var/log/security-alerts.log
   sudo chmod 640 /var/log/security-alerts.log
   sudo systemctl restart rsyslog
   ```

## Part 6: User Management

1. Create a script to add new users:
   ```bash
   sudo nano /usr/local/bin/add-bastion-user.sh
   ```
   
   Add:
   ```bash
   #!/bin/bash
   
   # Check if script is run as root
   if [ "$(id -u)" -ne 0 ]; then
     echo "This script must be run as root"
     exit 1
   fi
   
   # Check if username is provided
   if [ $# -lt 1 ]; then
     echo "Usage: $0 username"
     exit 1
   fi
   
   USERNAME=$1
   
   # Create user
   useradd -m -s /bin/bash $USERNAME
   
   echo "User $USERNAME created"
   echo "Their public key should be added to the GitHub repository through a PR"
   echo "Once approved, the key will be automatically deployed within 5 minutes"
   ```

2. Make the script executable:
   ```bash
   sudo chmod +x /usr/local/bin/add-bastion-user.sh
   ```

## Part 7: Preventing Local Authorized_Keys Modification

1. Disable user .ssh directory modifications:
   ```bash
   sudo nano /usr/local/bin/secure-ssh-dirs.sh
   ```
   
   Add:
   ```bash
   #!/bin/bash
   
   # For each user home directory
   for user in $(grep "/home/" /etc/passwd | cut -d: -f1); do
     # Create .ssh directory if it doesn't exist
     if [ ! -d "/home/$user/.ssh" ]; then
       mkdir -p "/home/$user/.ssh"
       chown $user:$user "/home/$user/.ssh"
       chmod 700 "/home/$user/.ssh"
     fi
     
     # Make it immutable
     if command -v chattr &>/dev/null; then
        chattr +i "/home/$user/.ssh"
     fi
     
     # Create a warning file
     echo "This directory is managed by the central SSH key system." > "/home/$user/.ssh/README"
     echo "Keys should be added through the GitHub repository." >> "/home/$user/.ssh/README"
     chown $user:$user "/home/$user/.ssh/README"
   done
   
   # Make the central authorized_keys immutable initially (update script handles it later)
   if [ -f /etc/ssh/authorized_keys ] && command -v chattr &>/dev/null; then
     chattr +i /etc/ssh/authorized_keys 2>/dev/null || true
   fi
   ```

2. Make the script executable and run it:
   ```bash
   sudo chmod +x /usr/local/bin/secure-ssh-dirs.sh
   sudo /usr/local/bin/secure-ssh-dirs.sh
   ```

3. Add to system startup:
   ```bash
   sudo nano /etc/rc.local
   ```
   
   Add before the `exit 0` line:
   ```bash
   # Secure SSH directories
   /usr/local/bin/secure-ssh-dirs.sh || true # Add || true to prevent boot issues if script fails
   ```
   
   Make it executable:
   ```bash
   sudo chmod +x /etc/rc.local
   ```

## Part 8: Final Steps and Verification

1. Restart SSH service:
   ```bash
   sudo systemctl restart sshd
   ```

2. Check SSH configuration:
   ```bash
   sudo sshd -t
   ```

3. Test the key update script:
   ```bash
   sudo /usr/local/bin/update_ssh_keys.sh
   ```

4. Verify audit log creation:
   ```bash
   sudo ls -la /var/log/user-sessions/
   ```

5. Create a test user and verify the setup:
   ```bash
   sudo /usr/local/bin/add-bastion-user.sh testuser
   ```
